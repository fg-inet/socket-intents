/** \file policy_video.c
 *  \brief Policy for video streaming
 *
 *  \copyright Copyright 2013-2019 Philipp Tiesel, Theresa Enghardt, and Mirko Palmer.
 *  All rights reserved. This project is released under the New BSD License.
 *
 *  This policy is optimist by default (i.e., it is the "Optimist Policy" unless specified otherwise in the config file).
 *  To get the Pessimist Policy, add the optiom "set pessimist = 1" to the configuration file (or just use pessimist_policy.conf where this is already done).
 *
 *  Intents:                     Category -- QUERY for small files, like manifest files or initial segments (that just contain information about the segments, no actual video data)
 *                                           BULK for large files, like video segments
 *                                           CONTROLTRAFFIC for "fake audio" (generated by modified wget)
 *
 *  Policy_info: Data structure for each prefix (roughly, each access network)
 *               In this policy: Whether this prefix is default,
 *                               Whether this prefix has connections available for reuse
 *                               Predicted load time estimates for each time scale
 *                               Count of how often this prefix was NOT picked for video segment
 *
 *  Behavior:
 *  Resolve Request - (Not supported)
 *  Connect         - (Not supported)
 *  Socketconnect   - Choose network based on capacity estimates and optimism or pessimism
 *  Socketchoose    - Choose network based on capacity estimates and optimism or pessimism, reuse connections if possible
 *
 *  Pseudocode of basic decisionmaking algorithm -- see details on optimist and pessimist below

		If (category = query) {
			Return(network with shortest minrtt)
		} Else If (category = controltraffic) {
			Return(network that was not recently used for video segment (i.e., with highest "count"))
		} Else If (category = bulk) {
			rsize = bitrate * segmentduration
			ForEach(network) {
				shorttermestimate = predictloadtime(minrtt, shorttermcapacity, reuse, usetls, rsize)
				// worst case load time based on shorttermcapacity of last 1 second
				midtermestimate = predictloadtime(minrtt, midtermcapacity, reuse, usetls, rsize)
				// expected load time based on midtermcapacity of last 10 seconds
				longtermestimate = predictloadtime(minrtt, longtermcapacity, reuse, usetls, rsize)
				// long term estimate based on longtermcapacity of last 1 minute
				verylongtermestimate = predictloadtime(minrtt, verylongtermcapacity, reuse, usetls, rsize)
				// best case based on verylongtermcapacity of last 10 minutes
			}

			candidate = network with shortest midtermestimate

			If (Optimist Policy) {
				Return(optimistalternative(candidate, segmentduration, bufferlevel, candidatelongtermestimate, candidateverylongtermestimate))
			} \Else If (Pessimist Policy) {
				Return(pessimistalternative(candidate, segmentduration, bufferlevel, candidateshorttermestimate, candidatemidtermestimate, candidatelongtermestimate))
			}
		}
 *
 * --- Optimist Policy ---
 *
	optimistalternative(candidate, segmentduration, bufferlevel, longtermestimate, verylongtermestimate){

		alternative = network with shortest verylongtermestimate
		// Compare to candidate with shortest midtermestimate

		If (bufferlevel = 0 and alternative not used for last segment) {
			Return alternative
			// Playout not started yet -- safe
		}

		If (alternative not used for last 3 segments){

			If (alternativelongtermestimate < (2/3) * bufferlevel) {
				Return alternative
				// Safe
			} Else If (candidatelongtermestimate > (2/3) * bufferlevel and alternativelongtermestimate < candidatelongtermestimate) {
				Return alternative
				// Not safe, but better
			} Else If(alternative not used last 10 segments) {
				Return alternative
				// Not used recently, try it
			}
		}
		Return(candidate)
		// If we have not switched

 * --- Pessimist Policy ---
 *
	pessimistalternative(candidate, segmentduration, bufferlevel, shorttermestimate, midtermestimate, longtermestimate){

		// candidate is network with shortest midtermestimate

		worstcaseloadtime = candidateshorttermestimate
		// If not available, use candidatemidtermestimate

		If (worstcaseloadtime > bufferlevel or segmentduration) {
			// Be concerned

			alternative = Network with shortest shorttermestimate

			If (alternativeshorttermestimate < bufferlevel) {
				Return (alternative)
				// safer to use
			} Else If (candidate used for last segment and worstcaseloadtime > (4/3) * bufferlevel) {

			// worstcaseloadtime likely accurate: Use alternative if faster for either estimate}

			If (alternativeshorttermestimate < candidateshorttermestimate) {

					Return (alternative)

			} Else If (alternativelongtermestimate < candidatelongtermestimate) {

					Return (alternative)
			}
		}
		Return (candidate)
		// We are not concerned or found no alternative
	}
 */

#include "policy.h"
#include "policy_util.h"

#define LATENCY_ESTIMATE "srtt_minimum_recent"
#define SHORTTERM_MAX_CAPACITY_ESTIMATE "download_sma_max"
#define MIN_CAPACITY_ESTIMATE "download_sma_nonzero_10q"
#define LONGTERM_MAX_CAPACITY_ESTIMATE "download_sma_max_long"
#define LONGTERM_MIN_CAPACITY_ESTIMATE "download_sma_nonzero_10q_long"
#define MIDTERM_MAX_CAPACITY_ESTIMATE "download_sma_max_mid"
#define MIDTERM_MIN_CAPACITY_ESTIMATE "download_sma_nonzero_10q_mid"
#define LONGLONGTERM_MAX_CAPACITY_ESTIMATE "download_sma_max_longlong"

// Segment duration in seconds -- needed to estimate file size from bitrate
#define SEGMENT_DURATION 4

/** Policy-specific per-prefix data structure that contains additional information */
struct video_info {
	int is_default;
    int reuse;
    double predicted_time_longlongterm;
    double predicted_time_longterm;
    double predicted_time_midterm;
    double predicted_time_shortterm;
    int not_picked_count;
};

/** List of enabled addresses for each address family */
GSList *in4_enabled = NULL;
GSList *in6_enabled = NULL;

enum time {
    LONGLONGTERM,
    LONGTERM,
    MIDTERM,
    SHORTTERM
};

static const char *logfile = NULL;

struct src_prefix_list *choose_prefix(request_context_t *rctx, strbuf_t *sb, intent_category_t category, int bitrate, int duration);
struct src_prefix_list *get_default_prefix(request_context_t *rctx, strbuf_t *sb);
struct src_prefix_list *get_shortest_time_prefix(GSList *spl, enum time what_term, strbuf_t *sb);
void predict_all_load_times(GSList *spl, int filesize, request_context_t *rctx, strbuf_t *sb);
void increment_non_chosen(GSList *spl, struct src_prefix_list *chosen);
struct src_prefix_list *get_not_recently_picked(GSList *spl, strbuf_t *sb);

struct src_prefix_list *consider_pessimist_switch(struct src_prefix_list *candidate, GSList *spl, strbuf_t *sb, int duration);
struct src_prefix_list *consider_optimist_switch(struct src_prefix_list *candidate, GSList *spl, strbuf_t *sb, int duration);

int resolve_name(request_context_t *rctx);

int be_pessimist = 0;
int be_optimist = 1;


/** Helper to set the policy information for each prefix
 *  Here, set is_default if prefix has been set as default in the config file
 */
void set_policy_info(gpointer elem, gpointer data)
{
	struct src_prefix_list *spl = elem;

	struct video_info *new = malloc(sizeof(struct video_info));
	new->is_default = 0;

	// Query the config dictionary for this prefix
	if (spl->policy_set_dict != NULL)
	{
		gpointer value = NULL;
		if (((value = g_hash_table_lookup(spl->policy_set_dict, "default")) != NULL) && value )
			new->is_default = 1;
	}
	spl->policy_info = new;
}

/** Helper to print policy info
 */
void print_policy_info(void *policy_info)
{
	struct video_info *info = policy_info;
	if (info->is_default)
		printf(" (default)");
}

/** Helper to free policy info at cleanup time */
void freepolicyinfo(gpointer elem, gpointer data)
{
	struct src_prefix_list *spl = elem;

	if (spl->policy_info != NULL)
		free(spl->policy_info);

	spl->policy_info = NULL;
}

/** Helper function
 *  Returns the default prefix, if any exists, otherwise NULL
 */
struct src_prefix_list *get_default_prefix(request_context_t *rctx, strbuf_t *sb)
{
	GSList *spl = NULL;
	struct src_prefix_list *cur = NULL;
	struct video_info *info = NULL;

	// If address family is specified, only look in its list, else look in both (v4 first)
	if (rctx->ctx->domain == AF_INET)
		spl = in4_enabled;
	else if (rctx->ctx->domain == AF_INET6)
		spl = in6_enabled;
	else
		spl = g_slist_concat(in4_enabled, in6_enabled);

	// Go through list of src prefixes
	while (spl != NULL)
	{
		// Look at per-prefix policy information
		cur = spl->data;
		info = (struct video_info *)cur->policy_info;
		if (info != NULL && info->is_default)
		{
			/* This prefix is configured as default. Return it */
			strbuf_printf(sb, "\tFound default prefix ");
	        _muacc_print_sockaddr(sb, cur->if_addrs->addr, cur->if_addrs->addr_len);
			strbuf_printf(sb, "\n");
			return cur;
		}
		spl = spl->next;
	}
	strbuf_printf(sb, "\tDid not find a default prefix %s%s\n", (rctx->ctx->domain == AF_INET) ? "for IPv4" : "", (rctx->ctx->domain == AF_INET6) ? "for IPv6" : "");

	return NULL;
}

/** get_not_recently_picked
 *  -- get the network with higher not_picked_count (without resetting it)
 */
struct src_prefix_list *get_not_recently_picked(GSList *spl, strbuf_t *sb)
{
	struct src_prefix_list *cur = NULL;
	struct video_info *info = NULL;
    int not_picked_max = 0;
    struct src_prefix_list *candidate = NULL;

	// Go through list of src prefixes
	while (spl != NULL)
	{
		// Look at per-prefix policy information
		cur = spl->data;
		info = (struct video_info *)cur->policy_info;
		if (info != NULL && info->not_picked_count > not_picked_max)
		{
		   candidate = cur;
		   not_picked_max = info->not_picked_count;
		}
		spl = spl->next;
	}

	return(candidate);
}
// Assuming object is capacity dominated, return prefix with lowest expected load time
void predict_all_load_times(GSList *spl, int filesize, request_context_t *rctx, strbuf_t *sb)
{
	// Go through list of possible source prefixes
	while (spl != NULL)
	{
		struct src_prefix_list *cur = spl->data;
        struct video_info *pfxinfo = cur->policy_info;
        strbuf_printf(sb, "\tEstimating load times on %s for resource of size %d\n", cur->if_name, filesize);

		// Predict FOUR completion times on this prefix:
        //     longlong term max capacity (10 minutes)
        //     longterm max capacity (1 minute)
        //     midterm max capacity (10 seconds)
        //     shortterm max capacity (1 second)
        //     with midterm max capacity, longterm max capacity, and short term min capacity
        double capacity_longlongterm = lookup_value(cur, LONGLONGTERM_MAX_CAPACITY_ESTIMATE, NULL);
        strbuf_printf(sb, "\t\tLONGLONG = %.3f", capacity_longlongterm);
        double capacity_longterm = lookup_value(cur, LONGTERM_MAX_CAPACITY_ESTIMATE, NULL);
        strbuf_printf(sb, "\tLONG = %.3f", capacity_longterm);
        double capacity_midterm = lookup_value(cur, MIDTERM_MAX_CAPACITY_ESTIMATE, NULL);
        strbuf_printf(sb, "\tMID  = %.3f", capacity_midterm);
        double capacity_shortterm = lookup_value(cur, SHORTTERM_MAX_CAPACITY_ESTIMATE, NULL);
        strbuf_printf(sb, "\tSHORT = %.3f\n", capacity_shortterm);

        double srtt = lookup_value(cur, "srtt_minimum_recent", NULL);
        strbuf_printf(sb, "\t\t(srtt_minimum_recent = %.3f)\n", (srtt < DBL_MAX ? srtt : -1));

        pfxinfo->predicted_time_longlongterm = predict_completion_time(cur, filesize, pfxinfo->reuse, NULL, (strncmp(rctx->ctx->remote_service, "443", 4) == 0 ? 1 : 0), capacity_longlongterm, "srtt_minimum_recent");
        pfxinfo->predicted_time_longterm = predict_completion_time(cur, filesize, pfxinfo->reuse, NULL, (strncmp(rctx->ctx->remote_service, "443", 4) == 0 ? 1 : 0), capacity_longterm, "srtt_minimum_recent");
        pfxinfo->predicted_time_midterm = predict_completion_time(cur, filesize, pfxinfo->reuse, NULL, (strncmp(rctx->ctx->remote_service, "443", 4) == 0 ? 1 : 0), capacity_midterm, "srtt_minimum_recent");
        pfxinfo->predicted_time_shortterm = predict_completion_time(cur, filesize, pfxinfo->reuse, NULL, (strncmp(rctx->ctx->remote_service, "443", 4) == 0 ? 1 : 0), capacity_shortterm, "srtt_minimum_recent");

        strbuf_printf(sb, "\t\tLonglong term: %.3f\n", (DBL_MAX - pfxinfo->predicted_time_longlongterm < EPSILON? -1 : pfxinfo->predicted_time_longlongterm));
        strbuf_printf(sb, "\t\tLong term: %.3f\n", (DBL_MAX - pfxinfo->predicted_time_longterm < EPSILON? -1 : pfxinfo->predicted_time_longterm));
        strbuf_printf(sb, "\t\tMid term: %.3f\n", (DBL_MAX - pfxinfo->predicted_time_midterm < EPSILON? -1 : pfxinfo->predicted_time_midterm));
        strbuf_printf(sb, "\t\tShort term: %.3f\n", (DBL_MAX - pfxinfo->predicted_time_shortterm < EPSILON? -1 : pfxinfo->predicted_time_shortterm));

		spl = spl->next;
	}
}

/** Pessimism: If worst case load time is too high, be concerned.
 *  Consider switching to another network which has an acceptable worst case
 *  load time.
 */
struct src_prefix_list *consider_pessimist_switch(struct src_prefix_list *candidate, GSList *spl, strbuf_t *sb, int duration) {

    if (duration < EPSILON) {
        // No current buffer level -- cannot compare worst case load time with it
        strbuf_printf(sb, "\t\tPlayout not started yet - skip being pessimist\n");
        return candidate;
    }
    strbuf_printf(sb, "\t\tBeing pessimist: ");

    // Determine worst case load time on candidate
    int how_concerned_are_we = 0;
    struct video_info *pxinfo = candidate->policy_info;
    double worst_case_load_time = pxinfo->predicted_time_shortterm;
    double duration_or_segment = (double) duration;
    if (duration_or_segment < 1000 * SEGMENT_DURATION) {
        duration_or_segment = 1000 * SEGMENT_DURATION;
    }

    if (DBL_MAX - pxinfo->predicted_time_shortterm < EPSILON) {
        worst_case_load_time = pxinfo->predicted_time_midterm;
        strbuf_printf(sb, "Short term estimate on this interface is N/A, so using mid term estimate %.2f", worst_case_load_time);
    } else {
        strbuf_printf(sb, "Worst case load time on this interface is %.2f ms", worst_case_load_time);
    }
    strbuf_printf(sb, " -- comparing to segment duration %d and buffer status duration %d (not_picked_count = %d)\n", SEGMENT_DURATION * 1000, duration, pxinfo->not_picked_count);

    // Determine how concerned we are:
    // 0 means "not concerned"
    // 1 means "concerned"
    // 2 means "very concerned"
    if (worst_case_load_time > (1.5 * duration_or_segment) && pxinfo->not_picked_count == 0) {
        // We have recently used this prefix and it gave us a bad worst case estimate
        how_concerned_are_we = 2;
        strbuf_printf(sb, "\t\tBe VERY concerned\n");

    } else if (worst_case_load_time > duration_or_segment) {
        if (pxinfo->not_picked_count > 0 && pxinfo->predicted_time_midterm < SEGMENT_DURATION * 1000) {
            strbuf_printf(sb, "\t\tPerhaps that estimate is not recent and midterm looks okay -- do not be concerned\n");
            return(candidate);
        } else {
            how_concerned_are_we = 1;
            strbuf_printf(sb, "\t\tBe concerned\n");
        }
    } else if (worst_case_load_time > SEGMENT_DURATION * 1000) {
        if (pxinfo->not_picked_count == 0 && pxinfo->predicted_time_midterm > duration_or_segment * 1.5) {
            how_concerned_are_we = 2;
            strbuf_printf(sb, "\t\tWe recently picked this and it has a terrible worst case estimate -- be VERY concerned\n");
        } else {
            how_concerned_are_we = 1;
            strbuf_printf(sb, "\t\tNot sure if I should be concerned, but I am\n");
        }
    } else {
        //strbuf_printf(sb, "\t\tSeems okay -- be optimist\n");
        strbuf_printf(sb, "\t\tSeems okay -- but DO NOT be optimist\n");
        return(candidate);
    }

    if (how_concerned_are_we > 0) {

        // See if there is an alternative with better short term load time
        struct src_prefix_list *alt_better_shortterm = get_shortest_time_prefix(spl, SHORTTERM, sb);

        if (alt_better_shortterm != NULL && alt_better_shortterm != candidate) {
            struct video_info *px2info = alt_better_shortterm->policy_info;
            strbuf_printf(sb, "\t\tConsidering to use %s with short term load time %.3f", alt_better_shortterm->if_name, px2info->predicted_time_shortterm);

            if (px2info->predicted_time_shortterm < duration) {
                strbuf_printf(sb, " -- is shorter than our buffer, picking it\n");
                return(alt_better_shortterm);
            } else if (px2info->predicted_time_shortterm < pxinfo->predicted_time_shortterm) {
                strbuf_printf(sb, " -- both longer than buffer, but alternative is less bad, picking it\n");
                return(alt_better_shortterm);
            } else {
                strbuf_printf(sb, " -- not picking it\n");
            }
        }

        // See if there is an alternative prefix with better mid term
        struct src_prefix_list *alt_better_midterm = get_shortest_time_prefix(spl, MIDTERM, sb);

        if (alt_better_midterm != NULL && alt_better_midterm != candidate) {
            struct video_info *px2info = alt_better_midterm->policy_info;
            strbuf_printf(sb, "\t\tConsidering to use %s with mid term load time %.3f", alt_better_midterm->if_name, px2info->predicted_time_midterm);

            if (px2info->not_picked_count == 0 && (px2info->predicted_time_midterm < SEGMENT_DURATION * 1000)) {
                // This prefix has recently been used -- its short and midterm
                // estimates should be about accurate, so only accept it if
                // the mid estimate is below segment duration
                strbuf_printf(sb, " -- is shorter than segment duration, picking it\n");
                return(alt_better_midterm);
            } else if (px2info->not_picked_count >= 1 && (px2info->predicted_time_midterm * 1.5 < duration)) {
                // This prefix has an acceptable midterm estimate
                strbuf_printf(sb, " -- is shorter than buffer, picking it\n");
                return(alt_better_midterm);
            } else {
                strbuf_printf(sb, " -- not picking it\n");
            }
        }

        // See if there is an alternative prefix with shorter long term load time
        struct src_prefix_list *alt_better_longterm = get_shortest_time_prefix(spl, LONGTERM, sb);

        if (alt_better_longterm != NULL && alt_better_longterm != candidate) {
            struct video_info *px2info = alt_better_longterm->policy_info;
            strbuf_printf(sb, "\t\tConsidering to use %s with long term load time %.3f", alt_better_longterm->if_name, px2info->predicted_time_longterm);

            /*if (px2info->predicted_time_longterm * 1.5 < duration) {
                strbuf_printf(sb, " -- is shorter than our buffer and has not been picked %d times, picking it\n", px2info->not_picked_count);
                return(alt_better_longterm);
            } else if (px2info->predicted_time_longterm * 1.5 < SEGMENT_DURATION * 1000) {
                strbuf_printf(sb, " -- is shorter than our segment duration and has not been picked %d times, picking it\n", px2info->not_picked_count);
                return(alt_better_longterm);
            } else {
                strbuf_printf(sb, " -- not picking it\n");
            }*/
        }

        // If worst case load time is more than 1.5 times the current buffer duration
        // we may be in trouble and are even more ready to switch
        if (how_concerned_are_we > 1) {
                strbuf_printf(sb, "\t\tvery concerned -- reconsidering alternatives\n");
            if (alt_better_shortterm != candidate && ((struct video_info *)alt_better_shortterm)->predicted_time_shortterm < pxinfo->predicted_time_shortterm) {
                strbuf_printf(sb, "\t\t%s has better worst case load time -- picking it\n", alt_better_shortterm->if_name);
                return(alt_better_shortterm);
            }
            if (alt_better_midterm != candidate) {
                struct video_info *px3info = alt_better_midterm->policy_info;
                if (px3info->predicted_time_shortterm < pxinfo->predicted_time_shortterm && px3info->predicted_time_midterm < pxinfo->predicted_time_midterm) {
                    strbuf_printf(sb, "\t\t%s has better mid term load time -- picking it\n", alt_better_midterm->if_name);
                    return(alt_better_midterm);
                }
            }
            if (alt_better_longterm != candidate) {
                struct video_info *px4info = alt_better_longterm->policy_info;
                if (px4info->predicted_time_shortterm < pxinfo->predicted_time_shortterm && px4info->predicted_time_longterm < pxinfo->predicted_time_longterm) {
                    strbuf_printf(sb, "\t\t%s still has better longterm load time -- picking it\n", alt_better_longterm->if_name);
                    return(alt_better_longterm);
                }
            }
        }
        strbuf_printf(sb, "\t\tcould not find an alternative -- staying with %s\n", candidate->if_name);
    }
    // If we did not find an alternative,
    // return the same candidate we got initially
    return candidate;
}

/** Optimism: If there is an alternative prefix with a better long term load time
 *  which has not been tried in a while, try it -- it might have gotten better!
 */
struct src_prefix_list *consider_optimist_switch(struct src_prefix_list *candidate, GSList *spl, strbuf_t *sb, int duration) {
    strbuf_printf(sb, "\t\tBeing optimist:");
    double duration_to_use = (double) duration;
    struct video_info *pxinfo = candidate->policy_info;

    // Get interface with lowest longterm best case load time as alternative
    struct src_prefix_list *alternative = get_shortest_time_prefix(spl, LONGLONGTERM, sb);

    if (alternative != NULL && alternative != candidate) {
        // This only makes sense if the alternative is different from the candidate
        struct video_info *px2info = alternative->policy_info;
        strbuf_printf(sb, " Considering to use %s with longlongterm load time %.3f and long term load time %.3f / mid term load time %.3f, not picked %d times\n", alternative->if_name, px2info->predicted_time_longlongterm, px2info->predicted_time_longterm, px2info->predicted_time_midterm, px2info->not_picked_count);

        if (duration < EPSILON && px2info->not_picked_count > 0) {
            // Give alternative, which has not been recently used, a chance
            strbuf_printf(sb, "\t\tPlayout hasn't started yet -- trying this");
            return(alternative);
        }

        if (px2info->not_picked_count > 3) {
            // Only consider optimist switch if alternative has not been used
            // recently, i.e., at least 3 times

            // If alternative is "safe to use", i.e., longterm says it will
            // be finished within buffer duration, try it
            if ((px2info->predicted_time_longterm * 1.5) < duration_to_use) {
            strbuf_printf(sb, "\t\tlong term predicted time * 1.5 = %f is acceptable with buffer = %.0f -- picking it\n", px2info->predicted_time_longterm * 1.5, duration_to_use);
                return(alternative);
            /*} else if ((px2info->predicted_time_longterm * 1.2) < duration_to_use) {
                // OPTIONAL: Consider using factor 1.2 if 1.5 means
                // we don't switch enough
                strbuf_printf(sb, " -- long term predicted time %f is acceptable compared to buffer * 1.2 = %.0f -- picking it\n", px2info->predicted_time_longterm, duration_to_use * 1.2);
                return(alternative);*/
            } else if ((pxinfo->predicted_time_longterm * 1.5) > duration_to_use && px2info->predicted_time_longterm < pxinfo->predicted_time_longterm) {
                // alternative may not be safe to use, but
                // candidate is not safe to use either
                // --> if alternative has better longterm estimate, try it
                strbuf_printf(sb, "\t\thas a better long term predicted time %f -- picking it\n", px2info->predicted_time_longterm);
                return(alternative);
            } else if (px2info->not_picked_count > 10) {
                strbuf_printf(sb, "\t\tlonglong term predicted time %f is better than candidate longlongterm and hasn't been tried %d times -- picking it\n", px2info->predicted_time_longlongterm, px2info->not_picked_count);
                return(alternative);
            }
        }
        // Found no reason to switch to alternative
        strbuf_printf(sb, "\t\tstaying with %s\n", candidate->if_name);
    } else {
        strbuf_printf(sb, "\t\tNo alternative found -- staying with %s\n", candidate->if_name);
    }

    // If we did not find an alternative,
    // return the same candidate we got initially
    return candidate;
}

void increment_non_chosen(GSList *spl, struct src_prefix_list *chosen)
{
	// Go through list of possible source prefixes
	while (spl != NULL)
	{
		struct src_prefix_list *cur = spl->data;
        struct video_info *pfxinfo = cur->policy_info;
        if (spl->data != chosen) {
            pfxinfo->not_picked_count++;
        }
		spl = spl->next;
	}
}

struct src_prefix_list *get_shortest_time_prefix(GSList *spl, enum time what_term, strbuf_t *sb)
{
	// Get prefix with shortest predicted completion time
	struct src_prefix_list *cur = NULL;
	struct src_prefix_list *fastest = NULL;
	double min_completion_time = DBL_MAX;

	while (spl != NULL)
	{
		cur = spl->data;
        if (cur->policy_info == NULL) {
            continue;
        }
        double time_to_look_at = DBL_MAX;
        if (what_term == LONGLONGTERM) {
            time_to_look_at = ((struct video_info *)cur->policy_info)->predicted_time_longlongterm;
        } else if (what_term == LONGTERM) {
            time_to_look_at = ((struct video_info *)cur->policy_info)->predicted_time_longterm;
        } else if (what_term == MIDTERM) {
            time_to_look_at = ((struct video_info *)cur->policy_info)->predicted_time_midterm;
        } else if (what_term == SHORTTERM) {
            time_to_look_at = ((struct video_info *)cur->policy_info)->predicted_time_shortterm;
        }
        if (time_to_look_at > 0 && time_to_look_at < min_completion_time)
        {
            fastest = cur;
            min_completion_time = time_to_look_at;
        }
        spl = spl->next;
	}

    return fastest;
}

/**
 *  Chooses the source prefix
 */
struct src_prefix_list *choose_prefix(request_context_t *rctx, strbuf_t *sb, intent_category_t category, int bitrate, int duration)
{
	GSList *spl = NULL;

	// If address family is specified, only look in its list, else look in both (v4 first)
	if (rctx->ctx->domain == AF_INET)
		spl = in4_enabled;
	else if (rctx->ctx->domain == AF_INET6)
		spl = in6_enabled;
	else
		spl = g_slist_concat(in4_enabled, in6_enabled);

    struct src_prefix_list *chosenpfx = NULL;

    if (category == INTENT_QUERY) {
        // Initial Query -- choose lowest latency prefix
        chosenpfx = get_lowest_srtt_pfx(spl, LATENCY_ESTIMATE, sb);
        strbuf_printf(sb, "\tLowest latency (%s) interface: %s\n", LATENCY_ESTIMATE, (chosenpfx == NULL) ? "none" : chosenpfx->if_name);
        if (chosenpfx != NULL) {
            _muacc_logtofile(logfile, "%s,lowlatency\n", chosenpfx->if_name);
        }
    } else if (category == INTENT_CONTROLTRAFFIC) {
        // "Control traffic" is our audio stream -- get not recently picked network
        chosenpfx = get_not_recently_picked(spl, sb);
        strbuf_printf(sb, "\tNot recently picked (%d) interface: %s\n", (chosenpfx == NULL) ? -1 : ((struct video_info *)chosenpfx->policy_info)->not_picked_count, (chosenpfx == NULL) ? "none" : chosenpfx->if_name);
        /*if (chosenpfx != NULL) {
            _muacc_logtofile(logfile, "%s,control\n", chosenpfx->if_name);
        }*/

    } else if (category == INTENT_BULKTRANSFER) {
        // Video segments -- estimate load time
        predict_all_load_times(spl, bitrate / 8 * SEGMENT_DURATION, rctx, sb);
        chosenpfx = get_shortest_time_prefix(spl, MIDTERM, sb);
        if (chosenpfx == NULL) {
            chosenpfx = get_shortest_time_prefix(spl, LONGTERM, sb);
        }
        if (chosenpfx == NULL) {
            chosenpfx = get_shortest_time_prefix(spl, LONGLONGTERM, sb);
        }
        strbuf_printf(sb, "\tShortest load time interface: %s\n", (chosenpfx == NULL) ? "none" : chosenpfx->if_name);

        if (chosenpfx != NULL && be_pessimist) {
            // See if we are concerned -- if not, consider optimist switch too
            chosenpfx = consider_pessimist_switch(chosenpfx, spl, sb, duration);
        } else if (chosenpfx != NULL) {
            // Only consider optimist switches
            chosenpfx = consider_optimist_switch(chosenpfx, spl, sb, duration);
        }

        if (chosenpfx != NULL) {
            struct video_info *chosen_info = chosenpfx->policy_info;
            chosen_info->not_picked_count = 0;
            increment_non_chosen(spl, chosenpfx);
            _muacc_logtofile(logfile, "%s,lowloadtime\n", chosenpfx->if_name);
        }
    }
    if (chosenpfx == NULL) {
        // No category given or no load time estimates -- return default prefix
        chosenpfx = get_default_prefix(rctx, sb);
        strbuf_printf(sb, "\tDefault interface: %s\n", (chosenpfx == NULL) ? "none" : chosenpfx->if_name);
        if (chosenpfx != NULL) {
            _muacc_logtofile(logfile, "%s,default\n", chosenpfx->if_name);
        } else {
            _muacc_logtofile(logfile, ",none\n");
        }
    }

	return chosenpfx;
}


/** Initializer function (mandatory)
 *  Is called once the policy is loaded and every time it is reloaded
 *  Typically sets the policy_info and initializes the lists of candidate addresses
 */
int init(mam_context_t *mctx)
{
	printf("Policy module \"video\" is loading.\n");

	g_slist_foreach(mctx->prefixes, &set_policy_info, NULL);

	make_v4v6_enabled_lists (mctx->prefixes, &in4_enabled, &in6_enabled);
    GSList *spl = in4_enabled;
    while (spl != NULL) {
        struct video_info *pfxinfo = ((struct src_prefix_list *)spl->data)->policy_info;
        pfxinfo->not_picked_count = 0;
        spl = spl->next;
    }
    spl = in6_enabled;
    while (spl != NULL) {
        struct video_info *pfxinfo = ((struct src_prefix_list *)spl->data)->policy_info;
        pfxinfo->not_picked_count = 0;
        spl = spl->next;
    }

	logfile = g_hash_table_lookup(mctx->policy_set_dict, "logfile");
	if (logfile != NULL)
	{
		printf("\nLogging to %s\n", logfile);
	}

    gpointer value = NULL;
    if ((value = g_hash_table_lookup(mctx->policy_set_dict, "be_pessimist")) != NULL) {
        be_pessimist = 1;
		printf("\nBeing pessimist\n");
	} else {
		be_pessimist = 0;
		printf("\nNot being pessimist\n");
	}

	printf("\nPolicy module \"video\" has been loaded.\n");
	return 0;
}

/** Cleanup function (mandatory)
 *  Is called once the policy is torn down, e.g. if MAM is terminates
 *  Tear down lists of candidate addresses (no deep free) and policy infos
 */
int cleanup(mam_context_t *mctx)
{
	g_slist_free(in4_enabled);
	g_slist_free(in6_enabled);
	g_slist_foreach(mctx->prefixes, &freepolicyinfo, NULL);

	in4_enabled = NULL;
	in6_enabled = NULL;

	printf("Policy video cleaned up.\n");
	return 0;
}

/** Asynchronous callback function for resolve_name
 *  Invoked once a response to the resolver query has been received
 *  Sends back a reply to the client with the received answer
 */
static void resolve_request_result(int errcode, struct evutil_addrinfo *addr, void *ptr)
{
	request_context_t *rctx = ptr;

	strbuf_t sb;
	strbuf_init(&sb);

	if (errcode) {
	    strbuf_printf(&sb, "\t[%.6f] Error resolving: %s -> %s\n", gettimestamp(), rctx->ctx->remote_hostname, evutil_gai_strerror(errcode));
		rctx->action = muacc_error_resolve;
	}
	else
	{
		// Successfully resolved name
		strbuf_printf(&sb, "\t[%.6f] Got resolver response for %s %s\n",
			gettimestamp(),
			rctx->ctx->remote_hostname,
			addr->ai_canonname ? addr->ai_canonname : "");

		strbuf_printf(&sb, "\t");
		_muacc_print_addrinfo(&sb, addr);
		strbuf_printf(&sb, "\n");

		// Clone result into the request context
		assert(addr != NULL);
		assert(rctx->ctx->remote_addrinfo_res == NULL);
		rctx->ctx->remote_addrinfo_res = _muacc_clone_addrinfo(addr);

		// Choose first result as the remote address
		rctx->ctx->domain = addr->ai_family;
		rctx->ctx->type = addr->ai_socktype;
		rctx->ctx->protocol = addr->ai_protocol;
		rctx->ctx->remote_sa_len = addr->ai_addrlen;
		rctx->ctx->remote_sa = _muacc_clone_sockaddr(addr->ai_addr, addr->ai_addrlen);

		// Print remote address
		strbuf_printf(&sb, "\n\tSet remote address =");
		_muacc_print_sockaddr(&sb, rctx->ctx->remote_sa, rctx->ctx->remote_sa_len);
		strbuf_printf(&sb, "\n");

        //strbuf_release(&sb);
		evutil_freeaddrinfo(addr);
	}

	// send reply to client
	strbuf_printf(&sb, "\n\t[%.6f] Sending reply\n", gettimestamp());
	_muacc_send_ctx_event(rctx, rctx->action);

    //printf("%s\n", strbuf_export(&sb));
    strbuf_release(&sb);
    //printf("\n\t[%.6f] Returning resolve result callback\n\n", gettimestamp());
}

/* Helper function that issues a DNS request
   and registers the callback resolve_request_result */
int resolve_name(request_context_t *rctx)
{
	strbuf_t sb;
	strbuf_init(&sb);

	struct evdns_base *evdns_base = rctx->evdns_base;

	// If no dns base is given for the chosen source prefix, use default dns base
	if (evdns_base == NULL) {
		strbuf_printf(&sb, "\tNo prefix-specific DNS base found - using default DNS base\n");
		evdns_base = rctx->mctx->evdns_default_base;
	}

	// Set hints to resolve name for our chosen address family
	if (rctx->ctx->remote_addrinfo_hint != NULL) {
		rctx->ctx->remote_addrinfo_hint->ai_family = rctx->ctx->domain;
	}
	else
	{
		// Initialize hints for address resolution
		rctx->ctx->remote_addrinfo_hint = malloc(sizeof(struct addrinfo));
		memset(rctx->ctx->remote_addrinfo_hint, 0, sizeof(struct addrinfo));
		rctx->ctx->remote_addrinfo_hint->ai_family = rctx->ctx->domain;
		rctx->ctx->remote_addrinfo_hint->ai_socktype = rctx->ctx->type;
		rctx->ctx->remote_addrinfo_hint->ai_protocol = rctx->ctx->protocol;
	}

	if (evdns_base_set_option(evdns_base, "timeout", "1") < 0)
	{
		strbuf_printf(&sb, "Setting DNS timeout failed\n");
	}

	strbuf_printf(&sb, "\t[%.6f] Resolving: %s:%s with hint: ", gettimestamp(), (rctx->ctx->remote_hostname == NULL ? "" : rctx->ctx->remote_hostname), (rctx->ctx->remote_service == NULL ? "" : rctx->ctx->remote_service));
	_muacc_print_addrinfo(&sb, rctx->ctx->remote_addrinfo_hint);
	strbuf_printf(&sb, "\n");

	/* Try to resolve this request using asynchronous lookup */
	assert(evdns_base != NULL);
	evdns_getaddrinfo(
			evdns_base,
			rctx->ctx->remote_hostname,
			rctx->ctx->remote_service,
			rctx->ctx->remote_addrinfo_hint,
			&resolve_request_result,
			rctx);

	//printf("%s\n", strbuf_export(&sb));
	strbuf_release(&sb);

	//printf("\t[%.6f] Returning resolve_name.\n\n", gettimestamp());
	return 0;
}

/** Resolve request function (mandatory)
 *  Is called upon each getaddrinfo request from a client
 *  Must send a reply back using _muacc_sent_ctx_event or register a callback that does so
 */
int on_resolve_request(request_context_t *rctx, struct event_base *base)
{
	//printf("\n\t[%.6f] Resolve request: %s:%s\n\n", gettimestamp(), (rctx->ctx->remote_hostname == NULL ? "" : rctx->ctx->remote_hostname), (rctx->ctx->remote_service == NULL ? "" : rctx->ctx->remote_service));

	if(rctx->ctx->bind_sa_req != NULL)
	{	// already bound
		//printf("\tBind interface already specified\n");
		rctx->ctx->domain = rctx->ctx->bind_sa_req->sa_family;

		struct src_prefix_list *bind_pfx = get_pfx_with_addr(rctx, rctx->ctx->bind_sa_req);
		if (bind_pfx != NULL) {
			// Set DNS base to this prefix's
			rctx->evdns_base = bind_pfx->evdns_base;
			//printf("\tSet DNS base\n");
		}
	}

	rctx->action = muacc_act_getaddrinfo_resolve_resp;

	//printf("\n\t[%.6f] Calling resolve_name\n", gettimestamp());
	return resolve_name(rctx);
}

/** Connect request function (mandatory)
 *  Is called upon each connect request from a client
 *  Must send a reply back using _muacc_sent_ctx_event or register a callback that does so
 */
int on_connect_request(request_context_t *rctx, struct event_base *base)
{
	strbuf_t sb;
	strbuf_init(&sb);
	strbuf_printf(&sb, "\t[%.6f] Connect request: dest=", gettimestamp());
	_muacc_print_sockaddr(&sb, rctx->ctx->remote_sa, rctx->ctx->remote_sa_len);

    // Print Intents
    intent_category_t category = -1;
    socklen_t categorylen = sizeof(intent_category_t);
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_CATEGORY, &categorylen, &category) == 0) {
        //printf("\t\twith category %d\n", category);
    }

	int fs = -1;
	socklen_t fslen = sizeof(int);
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_FILESIZE, &fslen, &fs) == 0) {
        //printf("\t\twith file size %d\n", fs);
    }

	int bitrate = -1;
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_BITRATE, &fslen, &bitrate) == 0) {
        //printf("\t\twith bitrate %d\n", bitrate);
    }

	int duration = -1;
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_DURATION, &fslen, &duration) == 0) {
        //printf("\t\twith duration %d\n", duration);
    }


	// Check if client has already chosen a source address to bind to
	if(rctx->ctx->bind_sa_req != NULL)
	{	// already bound
		strbuf_printf(&sb, "\tAlready bound to src=");
		_muacc_print_sockaddr(&sb, rctx->ctx->bind_sa_req, rctx->ctx->bind_sa_req_len);
		rctx->ctx->domain = rctx->ctx->bind_sa_req->sa_family;
	}
	else
	{
        struct src_prefix_list *bind_pfx = choose_prefix(rctx, &sb, category, bitrate, duration);
		if (bind_pfx != NULL) {
			set_bind_sa(rctx, bind_pfx, &sb);
		}
	}

	// send response back
	strbuf_printf(&sb, "\n\t[%.6f] Sending reply\n", gettimestamp());
	_muacc_send_ctx_event(rctx, muacc_act_connect_resp);

    //printf("%s\n", strbuf_export(&sb));
    strbuf_release(&sb);

	//printf("\t[%.6f] Returning\n\n", gettimestamp());
	return 0;
}

/** Socketconnect request function
 *  Is called upon each socketconnect request from a client
 *  Chooses a source prefix/address and then resolves the name
 *  Must send a reply back using _muacc_sent_ctx_event or register a callback that does so
 */
int on_socketconnect_request(request_context_t *rctx, struct event_base *base)
{
	strbuf_t sb;
	strbuf_init(&sb);

	printf("\n\t[%.6f] Socketconnect request: %s:%s\n", gettimestamp(), (rctx->ctx->remote_hostname == NULL ? "" : rctx->ctx->remote_hostname), (rctx->ctx->remote_service == NULL ? "" : rctx->ctx->remote_service));

    // Print Intents
    intent_category_t category = -1;
    socklen_t categorylen = sizeof(intent_category_t);
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_CATEGORY, &categorylen, &category) == 0) {
        printf("\t\twith category %d\n", category);
    }

	int fs = -1;
	socklen_t fslen = sizeof(int);
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_FILESIZE, &fslen, &fs) == 0) {
        printf("\t\twith file size %d\n", fs);
    }

	int bitrate = -1;
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_BITRATE, &fslen, &bitrate) == 0) {
        printf("\t\twith bitrate %d\n", bitrate);
    }

	int duration = -1;
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_DURATION, &fslen, &duration) == 0) {
        printf("\t\twith duration %d\n", duration);
    }

    printf("\n");

	double timestamp = gettimestamp();
	_muacc_logtofile(logfile, "%.6f,,,,,,,,%d,%d,%d,%d,", timestamp, fs, category, bitrate, duration);

	// Check if client has already chosen a source address to bind to
	if(rctx->ctx->bind_sa_req != NULL)
	{	// already bound
		strbuf_printf(&sb, "\tAlready bound to src=");
		_muacc_print_sockaddr(&sb, rctx->ctx->bind_sa_req, rctx->ctx->bind_sa_req_len);
		rctx->ctx->domain = rctx->ctx->bind_sa_req->sa_family;
		struct src_prefix_list *bind_pfx = get_pfx_with_addr(rctx, rctx->ctx->bind_sa_req);
		if (bind_pfx != NULL) {
			// Set DNS base to this prefix's
			rctx->evdns_base = bind_pfx->evdns_base;
			strbuf_printf(&sb, ", set DNS base. ");
		}
	}
	else
	{
        struct src_prefix_list *bind_pfx = choose_prefix(rctx, &sb, category, bitrate, duration);

		if (bind_pfx != NULL) {
			set_bind_sa(rctx, bind_pfx, &sb);

			// Set this prefix' evdns base for name resolution
			rctx->evdns_base = bind_pfx->evdns_base;
		}
		else
		{
			rctx->evdns_base = NULL;
		}
	}

    printf("%s\n\n", strbuf_export(&sb));
	strbuf_release(&sb);

	rctx->action = muacc_act_socketconnect_resp;

	return resolve_name(rctx);
}

/** Socketchoose request function
 *  Is called upon each socketchoose request from a client
 *  Chooses from a set of existing sockets, or if none exists, does the same as socketconnect
 *  Must send a reply back using _muacc_sent_ctx_event or register a callback that does so
 */
int on_socketchoose_request(request_context_t *rctx, struct event_base *base)
{
	strbuf_t sb;
	strbuf_init(&sb);

	printf("\n\t[%.6f] Socketchoose request: %s:%s", gettimestamp(), (rctx->ctx->remote_hostname == NULL ? "" : rctx->ctx->remote_hostname), (rctx->ctx->remote_service == NULL ? "" : rctx->ctx->remote_service));
    if (rctx->sockets != NULL)
    {
        printf(" with socketset: ");
        print_sockets(rctx->sockets);
    }
    printf("\n");

    // Print Intents
    intent_category_t category = -1;
    socklen_t categorylen = sizeof(intent_category_t);
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_CATEGORY, &categorylen, &category) == 0) {
        printf("\t\twith category %d\n", category);
    }

	int fs = -1;
	socklen_t fslen = sizeof(int);
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_FILESIZE, &fslen, &fs) == 0) {
        printf("\t\twith file size %d\n", fs);
    }

	int bitrate = -1;
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_BITRATE, &fslen, &bitrate) == 0) {
        printf("\t\twith bitrate %d\n", bitrate);
    }

	int duration = -1;
	if (mampol_get_socketopt(rctx->ctx->sockopts_current, SOL_INTENTS, INTENT_DURATION, &fslen, &duration) == 0) {
        printf("\t\twith duration %d\n", duration);
    }

    printf("\n");

	double timestamp = gettimestamp();
	_muacc_logtofile(logfile, "%.6f,", timestamp);
	GSList *spl = in4_enabled;
	while (spl != NULL)
	{
        struct src_prefix_list *cur = spl->data;
        struct video_info *pfxinfo = cur->policy_info;

		pfxinfo->reuse = count_sockets_on_prefix(rctx->sockets, cur, logfile);
		_muacc_logtofile(logfile, "%d,", pfxinfo->reuse);
		spl = spl->next;
	}
	_muacc_logtofile(logfile, ",,,%d,%d,%d,%d,", category, fs, bitrate, duration);

	struct src_prefix_list *bind_pfx = NULL;

	// Check if source address was already chosen
	if(rctx->ctx->bind_sa_req == NULL)
	{
		// No source address chosen yet - choose best prefix
		bind_pfx = choose_prefix(rctx, &sb, category, bitrate, duration);
		if (bind_pfx != NULL) {
			set_bind_sa(rctx, bind_pfx, &sb);

			// Set this prefix' evdns base for name resolution
			rctx->evdns_base = bind_pfx->evdns_base;
		}
	}
	else
	{
		strbuf_printf(&sb, "\tAlready bound to src=");
		_muacc_print_sockaddr(&sb, rctx->ctx->bind_sa_req, rctx->ctx->bind_sa_req_len);
		bind_pfx = get_pfx_with_addr(rctx, rctx->ctx->bind_sa_req);
	}

	// Attempt to suggest an existing socket on the preferred prefix
	if (bind_pfx != NULL && rctx->sockets != NULL)
	{
		strbuf_printf(&sb, "\n\tPicking a socket on prefix with address ");
		_muacc_print_sockaddr(&sb, bind_pfx->if_addrs->addr, bind_pfx->if_addrs->addr_len);
		strbuf_printf(&sb, "\n");

		// Filter the request context's socket list, only leaving sockets on our preferred prefix
		pick_sockets_on_prefix(rctx, bind_pfx);

		if (rctx-> sockets != NULL)
		{
			// At least one matching socket was found
			strbuf_printf(&sb, "\tFirst candidate socket: %d\n", rctx->sockets->file);

			/* Provide the information to open a new similar socket, in case the suggested socket cannot be used */
			uuid_t context_id;
			__uuid_copy(context_id, rctx->ctx->ctxid);
			_muacc_free_ctx(rctx->ctx);
			rctx->ctx = _muacc_clone_ctx(rctx->sockets->ctx);
			__uuid_copy(rctx->ctx->ctxid, context_id);

			printf("%s\n\n", strbuf_export(&sb));
			int ret = strbuf_release(&sb);
            if (ret > 0) {
                fprintf(stderr, "Strbuf could not be freed! %d\n", ret);
            }

			// Send reply back to client
			_muacc_send_ctx_event(rctx, muacc_act_socketchoose_resp_existing);

			return 0;
		}
		else
		{
			strbuf_printf(&sb, "\tDid not find a socket on this prefix\n");
		}
	}
	else
	{
		strbuf_printf(&sb, "\tSocketchoose with empty set or no preferred prefix found\n");
	}

	strbuf_printf(&sb, "\tSocketchoose - suggesting creation of a new socket, resolving %s\n", (rctx->ctx->remote_hostname == NULL ? "" : rctx->ctx->remote_hostname));

	rctx->action = muacc_act_socketchoose_resp_new;

	printf("%s\n\n", strbuf_export(&sb));
	int ret = strbuf_release(&sb);
    if (ret > 0) {
        fprintf(stderr, "Strbuf could not be freed! %d\n", ret);
    }

	return resolve_name(rctx);
}

int on_new_subflow_request(mam_context_t *mctx, struct mptcp_flow_info *flow)
{
    return 0;
}
